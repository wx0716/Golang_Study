当使用通用编程语言进行编写代码时，我们一定要认识到代码首先是写给人看的，只是恰好被机器编译和运行，而很难被人理解和维护的代码是非常糟糕。代码其实是按照约定格式编写的字符串，经过训练的软件工程师能对本来无意义的字符串进行分组和分析，按照约定的语法来理解源代码。并在机器内编译并运行程序。

既然工程师能够按照一定的方式理解和编译Golang语言的代码，那么我们如何模拟人理解源代码的方式构建一个能够分析编程语言代码的程序呢？我们在这一节将介绍词法分析和语法分析这两个重要的编译过程，这两个过程能将原本机器看起来无序意义的源文件转换成容易理解、分析并且结构化的抽象语法树。

### 词法分析

源代码在计算机“眼中”其实是一团乱麻、一个由字符组成的、无法被理解的字符串，所有的字符在计算机看来没什么区别，为了理解这些字符我们需要做的第一件事就是将**字符串分组**，这能够降低理解字符串的成本，简化源代码的过程。

```Go
make (chan int)
```

哪怕是不懂编程的人看到上述文本的第一反应也应该会将上述字符串分成几个部分：`make`、`chan`、`int`和括号，这个凭直觉分解文本的过程就是**词法分析**，词法分析就是将字符序列转换为标记(token)序列的过程。

#### lex

lex是用于生成词法分析器的工具，lex生成的代码能够将一个文件的字符分解成Token序列，很多语言在设计早期都会使用它快速设计出原型。词法分析作为具有固定模式的任务，出现这种更抽象的工具必然的。lex作为一个代码生成器，使用了类似C语言的语法，我们将lex理解为正则匹配的生成器，它会使用正则匹配扫描输入的字符流，下面是一个lex文件的示例：

```c
%{
#include
<stdio.h>
    %}

    %%
    package printf("PACKAGE ");
    import printf("IMPORT ");
    \. printf("DOT ");
    \{ printf("LBRACE ");
    \} printf("RBRACE ");
    \( printf("LPAREN ");
    \) printf("RPAREN ");
    \" printf("QUOTE ");
    \n printf("\n");
    [0-9]+ printf("NUMBER ");
    [a-zA-Z_]+ printf("IDENT ");
    %%
```

这个定义好的文件能够解析`package`和`import`关键字、常见的特俗字符、数字以及标识符，虽然这里的规则可能有一些简陋和不完善，但是用来解析下面的这一段代码还是比较轻松的：

```go
package main

import ""
(
fmt)

func main() {
	fmt.Println("Hello")
}
```

`.l`结尾的lex代码并不能直接运行，我们首先需要通过`lex`命令将上面的`simplego.l`展开成C语言代码，这里可以直接执行如下所示的命令编译并打印文件的内容：

```c
$ lex simplego.l
$ cat lex.yy.c
...
int yylex (void) {
	...
	while ( 1 ) {
		...
yy_match:
		do {
			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
			if ( yy_accept[yy_current_state] ) {
				(yy_last_accepting_state) = yy_current_state;
				(yy_last_accepting_cpos) = yy_cp;
			}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state ) {
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 30 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
		} while ( yy_base[yy_current_state] != 37 );
		...

do_action:
		switch ( yy_act )
			case 0:
    			...

			case 1:
    			YY_RULE_SETUP
    			printf("PACKAGE ");
    			YY_BREAK
			...
}
```

`lex.yy.c`的前600行基本都是宏和函数的声明和定义，后面生成的代码大都是为`yylex`这个函数服务的，这个函数使用**有限自动机**
的程序结构来分析输入的字符流，上述代码中`while`
循环就是这个有限自动机的主体，你如果仔细看这个文件生成的代码会发现当前的文件中并不存在`main`函数，`main`函数是在`liblex`
库中定义的，所以在编译时其实需要添加额外的`-ll`选项：

```shell
$ cc lex.yy.c -o simplego -ll
$ cat main.go | ./simplego
```

