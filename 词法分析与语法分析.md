当使用通用编程语言进行编写代码时，我们一定要认识到代码首先是写给人看的，只是恰好被机器编译和运行，而很难被人理解和维护的代码是非常糟糕。代码其实是按照约定格式编写的字符串，经过训练的软件工程师能对本来无意义的字符串进行分组和分析，按照约定的语法来理解源代码。并在机器内编译并运行程序。

既然工程师能够按照一定的方式理解和编译Golang语言的代码，那么我们如何模拟人理解源代码的方式构建一个能够分析编程语言代码的程序呢？我们在这一节将介绍词法分析和语法分析这两个重要的编译过程，这两个过程能将原本机器看起来无序意义的源文件转换成容易理解、分析并且结构化的抽象语法树。

### 词法分析

源代码在计算机“眼中”其实是一团乱麻、一个由字符组成的、无法被理解的字符串，所有的字符在计算机看来没什么区别，为了理解这些字符我们需要做的第一件事就是将**字符串分组**，这能够降低理解字符串的成本，简化源代码的过程。

```Go
make (chan int)
```

哪怕是不懂编程的人看到上述文本的第一反应也应该会将上述字符串分成几个部分：`make`、`chan`、`int`和括号，这个凭直觉分解文本的过程就是**词法分析**，词法分析就是将字符序列转换为标记(token)序列的过程。

#### lex

lex是用于生成词法分析器的工具，lex生成的代码能够将一个文件的字符分解成Token序列，很多语言在设计早期都会使用它快速设计出原型。词法分析作为具有固定模式的任务，出现这种更抽象的工具必然的。lex作为一个代码生成器，使用了类似C语言的语法，我们将lex理解为正则匹配的生成器，它会使用正则匹配扫描输入的字符流，下面是一个lex文件的示例：

```c
%{
#include
<stdio.h>
    %}

    %%
    package printf("PACKAGE ");
    import printf("IMPORT ");
    \. printf("DOT ");
    \{ printf("LBRACE ");
    \} printf("RBRACE ");
    \( printf("LPAREN ");
    \) printf("RPAREN ");
    \" printf("QUOTE ");
    \n printf("\n");
    [0-9]+ printf("NUMBER ");
    [a-zA-Z_]+ printf("IDENT ");
    %%
    ```