[TOC]

Golang语言是由Google公司开发的一种静态强类型、编译型、并发型、并具有垃圾回收功能的编程语言

### 1.语法简单

抛开语法样式不谈，单就类型和规则而言，Golang与C99、C11相似之处颇多，这也是Golang语言被冠以“NextC”名号的重要原因

Golang语言的语法处于简单和复杂的两极。C语言简单到你每写下一行代码，都能在脑海中想象出编译后的模样，指令如何执行、内存如何分配、等等。而C语言的复杂在于，它有太多隐晦而不着边际的规则，着实让人头疼。相比较而言，Golang从零开始，没有历史包袱，在汲取众多经验教训后，可从头规划一个规则严谨、条理简单的编程语言世界。

将“++”、“--”从运算符降级为语句，保留指针，但默认阻止指针运算，带来的好处是显而易见的。还有，将切片和字典作为内置类型，从运行时的层面进行优化，这也算是一种“简单”。

### 2.并发模型

Goroutine是Golang最显著的特征，它用类协程的方式来处理并发单元，却又在运行时层面做了更深度的优化处理。这使得语法上的并发编程变得极为容易，无需处理回调、无需关注线程切换，仅是一个关键字，简单而自然。

搭配channel，实现CSP模型。将并发单元间的数据耦合拆解开来，各司其职，这对所有纠结于内存共享、锁粒度的开发人员都是一个可期盼的解脱。若说有所不足，那就是应该有个更大的计划，将通信从进程内扩展到进程外，实现真正意义上的分布式。

### 3.内存分配

将一切并发话固然好，但带来的问题同样很多。如何实现高并发下的内存分配和管理就是个难题。好在Golang选择了tcmalloc，它本身就是为并发而设计的高性能内存分配组件。

可以说，内存分配器是运行时三大组件里变化最少得部分。刨去因配合垃圾回收器而修改的内容，内存分配器完整保留了tcmalloc的原始架构。使用cache为当前执行线程提供无锁分配，多个central在不同线程间平衡内存单元复用。在更高层次里，heap则管理着大块内存，用以切分成不同等级的复用内存块。快速分配和二级内存平衡机制，让内存分配器能优秀地完成高压力下的内存管理任务。

在最近几个版本中，编译器优化卓有成效。它会竭力将对象分配在栈上，以降低垃圾回收压力，减少管理消耗，提升执行效能。可以说，除偶尔因性能问题而被迫采用对象池和自主内存管理外，我们基本无需参与内存管理操作。

#### 4.垃圾回收

垃圾回收一直是个难题。早年间，Java就因垃圾回收低效被嘲笑了许久，后来Sun公司连续收纳了许多人和技术才发展到了今天。可即便如此，在Hadoop等大内存应用场景下，垃圾回收依旧捉襟见肘、步履维艰。

相比Java，Golang面临的困难要更多。因指针的存在，所以回收内存不能做收缩处理。幸好，指针运算被阻止，否则要做到精准回收很难。

每次升级时，垃圾回收器必然是核心组件里修改最多的部分。从并发清理，到降低STW时间，直到Golang的1.5版本实现并发标记，逐步引入三色标记和写屏障等等，都是为了能让垃圾回收在不影响用户逻辑的情况更好的工作。尽管有了努力，当前版本的垃圾回收算法只能算堪用，离好用尚有不小的距离。

### 5.静态链接

将运行时、依赖库直接打包到可执行文件内部，简化了部署和发布操作，无须事先安装运行环境和下载诸多第三方库。这种简单方式对于编写系统软件有着极大好处，因为库依赖一直都是个麻烦。

### 6.标准库

